// в очередь (macro)task добавится задача выводить в консоль James каждые 10 мкс
const intervalId = setInterval(() => {
  console.log('James');
}, 10);

// в очередь (macro)task добавится еще одна задача
setTimeout(() => {
  const promise = new Promise((resolve) => {
    console.log('Richard');
    resolve('Robert');
  });

  promise
      .then((value) => {
        console.log(value);

        setTimeout(() => {
          console.log('Michael');

          clearInterval(intervalId);
        }, 10);
      });

  console.log('John');
}, 10);

// Синхронный код закончился, начинается выполнение задач из очереди (macro)task.
// Первой в очереди задача вывода в консоль James каждые 10 мкс.
// Непонятно когда эта задача завершается. По здравому смыслу она не должна навсегда блокировать
// исполнение остального кода, т.е. наверно первое выполнение console.log приводит к разблокировке
// и новой записи в очередь.

// В итоге через 10 мкс увидим James.

// Дальше выполняется следующая задача из очереди, т.е. setTimeout. Вывод Richard выполнится через
// 10 мкс, сразу после James, а также произойдет запись промиса в очередь микрозадач, а также сразу
// вывод John.

// Синхронный код снова закончился, в очереди (macro)task сейчас предположительно задача вывести
// James второй раз, а в очереди микрозадач выполнение промиса, что и происходит в приоритетном
// порядке. Т.е. выводится Robert, плюс в очередь макрозадач попадает новая задача setTimeout.

// Синхронный код снова закончился, в очереди (macro)task сейчас первой стоит задача вывести James,
// она и выполняется. Далее выполняется вторая задача вывести Michael, плюс остановить дальнейший
// вывод James.

// Синхронный код окончательно закончился. Т.е. результат будет таким:
// James
// Richard
// John
// Robert
// James
// Michael

// P.S. Сначала я забыл про console.log('John') и решил задачу без него. Порядок был такой же,
// только без Джона в середине. Потом запустил на исполнение и увидел Джона и дописал решение
